// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addCourse = `-- name: AddCourse :one
INSERT INTO courses (title, description) VALUES ($1, $2) RETURNING id
`

type AddCourseParams struct {
	Title       pgtype.Text
	Description pgtype.Text
}

func (q *Queries) AddCourse(ctx context.Context, arg AddCourseParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, addCourse, arg.Title, arg.Description)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const disenrollUserInCourse = `-- name: DisenrollUserInCourse :exec
DELETE FROM usercourses WHERE user_id = $1 AND course_id = $2
`

type DisenrollUserInCourseParams struct {
	UserID   pgtype.Text
	CourseID pgtype.UUID
}

func (q *Queries) DisenrollUserInCourse(ctx context.Context, arg DisenrollUserInCourseParams) error {
	_, err := q.db.Exec(ctx, disenrollUserInCourse, arg.UserID, arg.CourseID)
	return err
}

const enrollUserInCourse = `-- name: EnrollUserInCourse :exec
INSERT INTO usercourses (user_id, course_id) VALUES ($1, $2)
`

type EnrollUserInCourseParams struct {
	UserID   pgtype.Text
	CourseID pgtype.UUID
}

func (q *Queries) EnrollUserInCourse(ctx context.Context, arg EnrollUserInCourseParams) error {
	_, err := q.db.Exec(ctx, enrollUserInCourse, arg.UserID, arg.CourseID)
	return err
}

const getCourse = `-- name: GetCourse :one
SELECT
  id,
  title,
  description,
  completion_title,
  completion_message
FROM courses WHERE id = $1
`

func (q *Queries) GetCourse(ctx context.Context, id pgtype.UUID) (Course, error) {
	row := q.db.QueryRow(ctx, getCourse, id)
	var i Course
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.CompletionTitle,
		&i.CompletionMessage,
	)
	return i, err
}

const getCourseMaterials = `-- name: GetCourseMaterials :many
SELECT
  id, name, position, storage_key
FROM course_materials
WHERE course_id = $1
ORDER BY position
`

type GetCourseMaterialsRow struct {
	ID         pgtype.UUID
	Name       string
	Position   pgtype.Int4
	StorageKey pgtype.UUID
}

func (q *Queries) GetCourseMaterials(ctx context.Context, courseID pgtype.UUID) ([]GetCourseMaterialsRow, error) {
	rows, err := q.db.Query(ctx, getCourseMaterials, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCourseMaterialsRow
	for rows.Next() {
		var i GetCourseMaterialsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Position,
			&i.StorageKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCourseQuizSections = `-- name: GetCourseQuizSections :many
SELECT
  qs.id,
  qs.position,
  qs.course_id,
  json_agg(
    json_build_object(
      'id', qq.id,
      'question', qq.question,
      'position', qq.position,
      'is_multi_answer', qq.is_multi_answer,
      'answers', (
        SELECT json_agg(
          json_build_object(
            'id', qa.id,
            'answer', qa.answer,
            'correct_answer', qa.correct_answer,
            'position', qa.position
          ) ORDER BY qa.position
        )
        FROM quizanswers qa
        WHERE qa.quiz_question_id = qq.id
      )
    ) ORDER BY qq.position
  ) AS questions
FROM quizsections qs
LEFT JOIN quizquestions qq ON qq.quiz_section_id = qs.id
WHERE qs.course_id = $1
GROUP BY qs.id, qs.position, qs.course_id
ORDER BY qs.position
`

type GetCourseQuizSectionsRow struct {
	ID        pgtype.UUID
	Position  pgtype.Int4
	CourseID  pgtype.UUID
	Questions []byte
}

func (q *Queries) GetCourseQuizSections(ctx context.Context, courseID pgtype.UUID) ([]GetCourseQuizSectionsRow, error) {
	rows, err := q.db.Query(ctx, getCourseQuizSections, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCourseQuizSectionsRow
	for rows.Next() {
		var i GetCourseQuizSectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Position,
			&i.CourseID,
			&i.Questions,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCourseVideoSections = `-- name: GetCourseVideoSections :many
SELECT
  id, title, position, storage_key
FROM videosections
WHERE course_id = $1
ORDER BY position
`

type GetCourseVideoSectionsRow struct {
	ID         pgtype.UUID
	Title      pgtype.Text
	Position   pgtype.Int4
	StorageKey pgtype.UUID
}

func (q *Queries) GetCourseVideoSections(ctx context.Context, courseID pgtype.UUID) ([]GetCourseVideoSectionsRow, error) {
	rows, err := q.db.Query(ctx, getCourseVideoSections, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCourseVideoSectionsRow
	for rows.Next() {
		var i GetCourseVideoSectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Position,
			&i.StorageKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProgress = `-- name: GetProgress :one
SELECT completed_intro, completed_section_ids FROM userprogress WHERE user_id = $1 AND course_id = $2
`

type GetProgressParams struct {
	UserID   string
	CourseID pgtype.UUID
}

type GetProgressRow struct {
	CompletedIntro      pgtype.Bool
	CompletedSectionIds []pgtype.UUID
}

func (q *Queries) GetProgress(ctx context.Context, arg GetProgressParams) (GetProgressRow, error) {
	row := q.db.QueryRow(ctx, getProgress, arg.UserID, arg.CourseID)
	var i GetProgressRow
	err := row.Scan(&i.CompletedIntro, &i.CompletedSectionIds)
	return i, err
}

const isUserEnrolledInCourse = `-- name: IsUserEnrolledInCourse :one
SELECT EXISTS(SELECT 1 FROM usercourses WHERE user_id = $1 AND course_id = $2)
`

type IsUserEnrolledInCourseParams struct {
	UserID   pgtype.Text
	CourseID pgtype.UUID
}

func (q *Queries) IsUserEnrolledInCourse(ctx context.Context, arg IsUserEnrolledInCourseParams) (bool, error) {
	row := q.db.QueryRow(ctx, isUserEnrolledInCourse, arg.UserID, arg.CourseID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateProgress = `-- name: UpdateProgress :exec
INSERT INTO userprogress (user_id, course_id, completed_section_ids)
VALUES ($1, $2, ARRAY[$3::uuid])
ON CONFLICT (user_id, course_id)
DO UPDATE SET completed_section_ids = array_append(userprogress.completed_section_ids, $3::uuid)
WHERE NOT ($3 = ANY(userprogress.completed_section_ids))
`

type UpdateProgressParams struct {
	UserID    string
	CourseID  pgtype.UUID
	SectionID pgtype.UUID
}

func (q *Queries) UpdateProgress(ctx context.Context, arg UpdateProgressParams) error {
	_, err := q.db.Exec(ctx, updateProgress, arg.UserID, arg.CourseID, arg.SectionID)
	return err
}
