// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: quiz.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteQuizAttempts = `-- name: DeleteQuizAttempts :exec
DELETE FROM quiz_attempts WHERE user_id = $1 AND quiz_id = $2
`

type DeleteQuizAttemptsParams struct {
	UserID string
	QuizID pgtype.UUID
}

func (q *Queries) DeleteQuizAttempts(ctx context.Context, arg DeleteQuizAttemptsParams) error {
	_, err := q.db.Exec(ctx, deleteQuizAttempts, arg.UserID, arg.QuizID)
	return err
}

const deleteUserQuizState = `-- name: DeleteUserQuizState :exec
DELETE FROM user_quiz_state WHERE user_id = $1 AND quiz_id = $2
`

type DeleteUserQuizStateParams struct {
	UserID string
	QuizID pgtype.UUID
}

func (q *Queries) DeleteUserQuizState(ctx context.Context, arg DeleteUserQuizStateParams) error {
	_, err := q.db.Exec(ctx, deleteUserQuizState, arg.UserID, arg.QuizID)
	return err
}

const getAllQuizSections = `-- name: GetAllQuizSections :many
SELECT
  qs.id,
  qs.position,
  qs.course_id,
  json_agg(
    json_build_object(
      'id', qq.id,
      'question', qq.question,
      'position', qq.position,
      'is_multi_answer', qq.is_multi_answer,
      'answers', (
        SELECT json_agg(
          json_build_object(
            'id', qa.id,
            'answer', qa.answer,
            'correct_answer', qa.correct_answer,
            'position', qa.position
          ) ORDER BY qa.position
        )
        FROM quizanswers qa
        WHERE qa.quiz_question_id = qq.id
      )
    ) ORDER BY qq.position
  ) AS questions
FROM quizsections qs
LEFT JOIN quizquestions qq ON qq.quiz_section_id = qs.id
GROUP BY qs.id, qs.position, qs.course_id
ORDER BY qs.course_id, qs.position
`

type GetAllQuizSectionsRow struct {
	ID        pgtype.UUID
	Position  pgtype.Int4
	CourseID  pgtype.UUID
	Questions []byte
}

func (q *Queries) GetAllQuizSections(ctx context.Context) ([]GetAllQuizSectionsRow, error) {
	rows, err := q.db.Query(ctx, getAllQuizSections)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllQuizSectionsRow
	for rows.Next() {
		var i GetAllQuizSectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Position,
			&i.CourseID,
			&i.Questions,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuizAttemptsByUserID = `-- name: GetQuizAttemptsByUserID :many
SELECT
  qah.id,
  uqs.user_id,
  uqs.quiz_id,
  qah.answers,
  qah.attempt_number,
  uqs.attempts AS total_attempts
FROM user_quiz_state uqs
LEFT JOIN quiz_attempts qah ON qah.user_id = uqs.user_id AND qah.quiz_id = uqs.quiz_id
WHERE uqs.user_id = $1
ORDER BY uqs.quiz_id, qah.attempt_number
`

type GetQuizAttemptsByUserIDRow struct {
	ID            pgtype.UUID
	UserID        string
	QuizID        pgtype.UUID
	Answers       []byte
	AttemptNumber pgtype.Int4
	TotalAttempts int32
}

func (q *Queries) GetQuizAttemptsByUserID(ctx context.Context, userID string) ([]GetQuizAttemptsByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getQuizAttemptsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetQuizAttemptsByUserIDRow
	for rows.Next() {
		var i GetQuizAttemptsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.QuizID,
			&i.Answers,
			&i.AttemptNumber,
			&i.TotalAttempts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuizStatesByUserID = `-- name: GetQuizStatesByUserID :many
SELECT quiz_id, quiz_state_v2 FROM user_quiz_state WHERE user_id = $1
`

type GetQuizStatesByUserIDRow struct {
	QuizID      pgtype.UUID
	QuizStateV2 []byte
}

func (q *Queries) GetQuizStatesByUserID(ctx context.Context, userID string) ([]GetQuizStatesByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getQuizStatesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetQuizStatesByUserIDRow
	for rows.Next() {
		var i GetQuizStatesByUserIDRow
		if err := rows.Scan(&i.QuizID, &i.QuizStateV2); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementAttempts = `-- name: IncrementAttempts :exec
INSERT INTO user_quiz_state (user_id, quiz_id, attempts)
VALUES (
  $1,
  $2,
  1
)
ON CONFLICT (user_id, quiz_id)
DO UPDATE SET attempts = user_quiz_state.attempts + 1
`

type IncrementAttemptsParams struct {
	UserID string
	QuizID pgtype.UUID
}

func (q *Queries) IncrementAttempts(ctx context.Context, arg IncrementAttemptsParams) error {
	_, err := q.db.Exec(ctx, incrementAttempts, arg.UserID, arg.QuizID)
	return err
}

const saveQuizAttempt = `-- name: SaveQuizAttempt :exec
INSERT INTO quiz_attempts (user_id, quiz_id, answers, attempt_number)
VALUES (
  $1,
  $2,
  $3,
  (SELECT COALESCE(MAX(attempt_number), 0) + 1 FROM quiz_attempts WHERE user_id = $1 AND quiz_id = $2)
)
`

type SaveQuizAttemptParams struct {
	UserID  string
	QuizID  pgtype.UUID
	Answers []byte
}

func (q *Queries) SaveQuizAttempt(ctx context.Context, arg SaveQuizAttemptParams) error {
	_, err := q.db.Exec(ctx, saveQuizAttempt, arg.UserID, arg.QuizID, arg.Answers)
	return err
}

const upsertQuizState = `-- name: UpsertQuizState :exec
INSERT INTO user_quiz_state (user_id, quiz_id, quiz_state_v2)
VALUES ($1, $2, $3)
ON CONFLICT (user_id, quiz_id)
DO UPDATE SET quiz_state_v2 = EXCLUDED.quiz_state_v2
`

type UpsertQuizStateParams struct {
	UserID      string
	QuizID      pgtype.UUID
	QuizStateV2 []byte
}

func (q *Queries) UpsertQuizState(ctx context.Context, arg UpsertQuizStateParams) error {
	_, err := q.db.Exec(ctx, upsertQuizState, arg.UserID, arg.QuizID, arg.QuizStateV2)
	return err
}
