// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: quiz.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getQuizAttemptsByUserID = `-- name: GetQuizAttemptsByUserID :many
SELECT
  qah.id,
  uqs.user_id,
  uqs.quiz_id,
  qah.attempt_data,
  qah.attempt_number,
  uqs.attempts AS total_attempts
FROM user_quiz_state uqs
LEFT JOIN quiz_attempts qah ON qah.user_id = uqs.user_id AND qah.quiz_id = uqs.quiz_id
WHERE uqs.user_id = $1
ORDER BY uqs.quiz_id, qah.attempt_number
`

type GetQuizAttemptsByUserIDRow struct {
	ID            pgtype.UUID
	UserID        string
	QuizID        pgtype.UUID
	AttemptData   []byte
	AttemptNumber pgtype.Int4
	TotalAttempts int32
}

func (q *Queries) GetQuizAttemptsByUserID(ctx context.Context, userID string) ([]GetQuizAttemptsByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getQuizAttemptsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetQuizAttemptsByUserIDRow
	for rows.Next() {
		var i GetQuizAttemptsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.QuizID,
			&i.AttemptData,
			&i.AttemptNumber,
			&i.TotalAttempts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementAttempts = `-- name: IncrementAttempts :exec
INSERT INTO user_quiz_state (user_id, quiz_id, attempts)
VALUES (
  $1,
  $2,
  1
)
ON CONFLICT (user_id, quiz_id)
DO UPDATE SET attempts = user_quiz_state.attempts + 1
`

type IncrementAttemptsParams struct {
	UserID string
	QuizID pgtype.UUID
}

func (q *Queries) IncrementAttempts(ctx context.Context, arg IncrementAttemptsParams) error {
	_, err := q.db.Exec(ctx, incrementAttempts, arg.UserID, arg.QuizID)
	return err
}

const saveQuizAttempt = `-- name: SaveQuizAttempt :exec
INSERT INTO quiz_attempts (user_id, quiz_id, attempt_data, attempt_number)
VALUES (
  $1,
  $2,
  $3,
  (SELECT COALESCE(MAX(attempt_number), 0) + 1 FROM quiz_attempts WHERE user_id = $1 AND quiz_id = $2)
)
`

type SaveQuizAttemptParams struct {
	UserID      string
	QuizID      pgtype.UUID
	AttemptData []byte
}

func (q *Queries) SaveQuizAttempt(ctx context.Context, arg SaveQuizAttemptParams) error {
	_, err := q.db.Exec(ctx, saveQuizAttempt, arg.UserID, arg.QuizID, arg.AttemptData)
	return err
}

const upsertQuizState = `-- name: UpsertQuizState :exec
INSERT INTO user_quiz_state (user_id, quiz_id, quiz_state_v2)
VALUES ($1, $2, $3)
ON CONFLICT (user_id, quiz_id)
DO UPDATE SET quiz_state_v2 = EXCLUDED.quiz_state_v2
`

type UpsertQuizStateParams struct {
	UserID      string
	QuizID      pgtype.UUID
	QuizStateV2 []byte
}

func (q *Queries) UpsertQuizState(ctx context.Context, arg UpsertQuizStateParams) error {
	_, err := q.db.Exec(ctx, upsertQuizState, arg.UserID, arg.QuizID, arg.QuizStateV2)
	return err
}
