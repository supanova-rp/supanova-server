// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: progress.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getProgress = `-- name: GetProgress :one
SELECT completed_intro, completed_section_ids FROM userprogress WHERE user_id = $1 AND course_id = $2
`

type GetProgressParams struct {
	UserID   string
	CourseID pgtype.UUID
}

type GetProgressRow struct {
	CompletedIntro      pgtype.Bool
	CompletedSectionIds []pgtype.UUID
}

func (q *Queries) GetProgress(ctx context.Context, arg GetProgressParams) (GetProgressRow, error) {
	row := q.db.QueryRow(ctx, getProgress, arg.UserID, arg.CourseID)
	var i GetProgressRow
	err := row.Scan(&i.CompletedIntro, &i.CompletedSectionIds)
	return i, err
}

const hasCompletedCourse = `-- name: HasCompletedCourse :one
SELECT completed_course FROM userprogress WHERE user_id = $1 AND course_id = $2
`

type HasCompletedCourseParams struct {
	UserID   string
	CourseID pgtype.UUID
}

func (q *Queries) HasCompletedCourse(ctx context.Context, arg HasCompletedCourseParams) (pgtype.Bool, error) {
	row := q.db.QueryRow(ctx, hasCompletedCourse, arg.UserID, arg.CourseID)
	var completed_course pgtype.Bool
	err := row.Scan(&completed_course)
	return completed_course, err
}

const setCourseCompleted = `-- name: SetCourseCompleted :exec
INSERT INTO userprogress (user_id, course_id, completed_section_ids, completed_course)
VALUES ($1, $2, ARRAY[]::uuid[], TRUE)
ON CONFLICT (user_id, course_id)
DO UPDATE SET completed_course = TRUE
`

type SetCourseCompletedParams struct {
	UserID   string
	CourseID pgtype.UUID
}

// If there is no existing userprogress (should not happen since user should have some progress already)
// then insert new row with empty completed_section_ids */
func (q *Queries) SetCourseCompleted(ctx context.Context, arg SetCourseCompletedParams) error {
	_, err := q.db.Exec(ctx, setCourseCompleted, arg.UserID, arg.CourseID)
	return err
}

const updateProgress = `-- name: UpdateProgress :exec
INSERT INTO userprogress (user_id, course_id, completed_section_ids)
VALUES ($1, $2, ARRAY[$3::uuid])
ON CONFLICT (user_id, course_id)
DO UPDATE SET completed_section_ids = array_append(userprogress.completed_section_ids, $3::uuid)
WHERE NOT ($3 = ANY(userprogress.completed_section_ids))
`

type UpdateProgressParams struct {
	UserID    string
	CourseID  pgtype.UUID
	SectionID pgtype.UUID
}

// Insert section_id into completed_section_ids array if no entry exists
// or append section_id to the existing array if it's not already present
func (q *Queries) UpdateProgress(ctx context.Context, arg UpdateProgressParams) error {
	_, err := q.db.Exec(ctx, updateProgress, arg.UserID, arg.CourseID, arg.SectionID)
	return err
}
