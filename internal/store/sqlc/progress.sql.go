// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: progress.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAllProgress = `-- name: GetAllProgress :many
SELECT
  COALESCE(uc.user_id, up.user_id) AS user_id,
  COALESCE(uc.course_id, up.course_id) AS course_id,
  u.name as user_name,
  u.email,
  c.title as course_title,
  up.completed_intro,
  up.completed_section_ids,
  up.completed_course
FROM usercourses uc
FULL OUTER JOIN userprogress up
  ON uc.user_id = up.user_id
  AND uc.course_id = up.course_id
LEFT JOIN users u
  ON u.id = COALESCE(uc.user_id, up.user_id)
LEFT JOIN courses c
  ON c.id = COALESCE(uc.course_id, up.course_id)
`

type GetAllProgressRow struct {
	UserID              string
	CourseID            pgtype.UUID
	UserName            pgtype.Text
	Email               pgtype.Text
	CourseTitle         pgtype.Text
	CompletedIntro      pgtype.Bool
	CompletedSectionIds []pgtype.UUID
	CompletedCourse     pgtype.Bool
}

func (q *Queries) GetAllProgress(ctx context.Context) ([]GetAllProgressRow, error) {
	rows, err := q.db.Query(ctx, getAllProgress)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllProgressRow
	for rows.Next() {
		var i GetAllProgressRow
		if err := rows.Scan(
			&i.UserID,
			&i.CourseID,
			&i.UserName,
			&i.Email,
			&i.CourseTitle,
			&i.CompletedIntro,
			&i.CompletedSectionIds,
			&i.CompletedCourse,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompletedSectionIDsByUserID = `-- name: GetCompletedSectionIDsByUserID :many
SELECT completed_section_ids FROM userprogress WHERE user_id = $1
`

func (q *Queries) GetCompletedSectionIDsByUserID(ctx context.Context, userID string) ([][]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, getCompletedSectionIDsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items [][]pgtype.UUID
	for rows.Next() {
		var completed_section_ids []pgtype.UUID
		if err := rows.Scan(&completed_section_ids); err != nil {
			return nil, err
		}
		items = append(items, completed_section_ids)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProgress = `-- name: GetProgress :one
SELECT completed_intro, completed_section_ids FROM userprogress WHERE user_id = $1 AND course_id = $2
`

type GetProgressParams struct {
	UserID   string
	CourseID pgtype.UUID
}

type GetProgressRow struct {
	CompletedIntro      pgtype.Bool
	CompletedSectionIds []pgtype.UUID
}

func (q *Queries) GetProgress(ctx context.Context, arg GetProgressParams) (GetProgressRow, error) {
	row := q.db.QueryRow(ctx, getProgress, arg.UserID, arg.CourseID)
	var i GetProgressRow
	err := row.Scan(&i.CompletedIntro, &i.CompletedSectionIds)
	return i, err
}

const hasCompletedCourse = `-- name: HasCompletedCourse :one
SELECT completed_course FROM userprogress WHERE user_id = $1 AND course_id = $2
`

type HasCompletedCourseParams struct {
	UserID   string
	CourseID pgtype.UUID
}

func (q *Queries) HasCompletedCourse(ctx context.Context, arg HasCompletedCourseParams) (pgtype.Bool, error) {
	row := q.db.QueryRow(ctx, hasCompletedCourse, arg.UserID, arg.CourseID)
	var completed_course pgtype.Bool
	err := row.Scan(&completed_course)
	return completed_course, err
}

const setCourseCompleted = `-- name: SetCourseCompleted :exec
INSERT INTO userprogress (user_id, course_id, completed_section_ids, completed_course)
VALUES ($1, $2, ARRAY[]::uuid[], TRUE)
ON CONFLICT (user_id, course_id)
DO UPDATE SET completed_course = TRUE
`

type SetCourseCompletedParams struct {
	UserID   string
	CourseID pgtype.UUID
}

// If there is no existing userprogress (should not happen since user should have some progress already)
// then insert new row with empty completed_section_ids */
func (q *Queries) SetCourseCompleted(ctx context.Context, arg SetCourseCompletedParams) error {
	_, err := q.db.Exec(ctx, setCourseCompleted, arg.UserID, arg.CourseID)
	return err
}

const updateProgress = `-- name: UpdateProgress :exec
INSERT INTO userprogress (user_id, course_id, completed_section_ids)
VALUES ($1, $2, ARRAY[$3::uuid])
ON CONFLICT (user_id, course_id)
DO UPDATE SET completed_section_ids = array_append(userprogress.completed_section_ids, $3::uuid)
WHERE NOT ($3 = ANY(userprogress.completed_section_ids))
`

type UpdateProgressParams struct {
	UserID    string
	CourseID  pgtype.UUID
	SectionID pgtype.UUID
}

// Insert section_id into completed_section_ids array if no entry exists
// or append section_id to the existing array if it's not already present
func (q *Queries) UpdateProgress(ctx context.Context, arg UpdateProgressParams) error {
	_, err := q.db.Exec(ctx, updateProgress, arg.UserID, arg.CourseID, arg.SectionID)
	return err
}
