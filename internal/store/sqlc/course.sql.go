// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: course.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addCourse = `-- name: AddCourse :one
INSERT INTO courses (title, description, completion_title, completion_message)
VALUES ($1, $2, $3, $4) RETURNING id
`

type AddCourseParams struct {
	Title             pgtype.Text
	Description       pgtype.Text
	CompletionTitle   pgtype.Text
	CompletionMessage pgtype.Text
}

func (q *Queries) AddCourse(ctx context.Context, arg AddCourseParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, addCourse,
		arg.Title,
		arg.Description,
		arg.CompletionTitle,
		arg.CompletionMessage,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteCourse = `-- name: DeleteCourse :exec
DELETE FROM courses WHERE id = $1
`

func (q *Queries) DeleteCourse(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteCourse, id)
	return err
}

const getCourse = `-- name: GetCourse :one
SELECT
  id,
  title,
  description,
  completion_title,
  completion_message
FROM courses WHERE id = $1
`

func (q *Queries) GetCourse(ctx context.Context, id pgtype.UUID) (Course, error) {
	row := q.db.QueryRow(ctx, getCourse, id)
	var i Course
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.CompletionTitle,
		&i.CompletionMessage,
	)
	return i, err
}

const getCourseMaterials = `-- name: GetCourseMaterials :many
SELECT
  id, name, position, storage_key
FROM course_materials
WHERE course_id = $1
ORDER BY position
`

type GetCourseMaterialsRow struct {
	ID         pgtype.UUID
	Name       string
	Position   pgtype.Int4
	StorageKey pgtype.UUID
}

func (q *Queries) GetCourseMaterials(ctx context.Context, courseID pgtype.UUID) ([]GetCourseMaterialsRow, error) {
	rows, err := q.db.Query(ctx, getCourseMaterials, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCourseMaterialsRow
	for rows.Next() {
		var i GetCourseMaterialsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Position,
			&i.StorageKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCourseQuizSections = `-- name: GetCourseQuizSections :many
SELECT
  qs.id,
  qs.position,
  qs.course_id,
  json_agg(
    json_build_object(
      'id', qq.id,
      'question', qq.question,
      'position', qq.position,
      'is_multi_answer', qq.is_multi_answer,
      'answers', (
        SELECT json_agg(
          json_build_object(
            'id', qa.id,
            'answer', qa.answer,
            'correct_answer', qa.correct_answer,
            'position', qa.position
          ) ORDER BY qa.position
        )
        FROM quizanswers qa
        WHERE qa.quiz_question_id = qq.id
      )
    ) ORDER BY qq.position
  ) AS questions
FROM quizsections qs
LEFT JOIN quizquestions qq ON qq.quiz_section_id = qs.id
WHERE qs.course_id = $1
GROUP BY qs.id, qs.position, qs.course_id
ORDER BY qs.position
`

type GetCourseQuizSectionsRow struct {
	ID        pgtype.UUID
	Position  pgtype.Int4
	CourseID  pgtype.UUID
	Questions []byte
}

func (q *Queries) GetCourseQuizSections(ctx context.Context, courseID pgtype.UUID) ([]GetCourseQuizSectionsRow, error) {
	rows, err := q.db.Query(ctx, getCourseQuizSections, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCourseQuizSectionsRow
	for rows.Next() {
		var i GetCourseQuizSectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Position,
			&i.CourseID,
			&i.Questions,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCourseVideoSections = `-- name: GetCourseVideoSections :many
SELECT
  id, title, position, storage_key
FROM videosections
WHERE course_id = $1
ORDER BY position
`

type GetCourseVideoSectionsRow struct {
	ID         pgtype.UUID
	Title      pgtype.Text
	Position   pgtype.Int4
	StorageKey pgtype.UUID
}

func (q *Queries) GetCourseVideoSections(ctx context.Context, courseID pgtype.UUID) ([]GetCourseVideoSectionsRow, error) {
	rows, err := q.db.Query(ctx, getCourseVideoSections, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCourseVideoSectionsRow
	for rows.Next() {
		var i GetCourseVideoSectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Position,
			&i.StorageKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoursesOverview = `-- name: GetCoursesOverview :many
SELECT id, title, description FROM courses ORDER BY title
`

type GetCoursesOverviewRow struct {
	ID          pgtype.UUID
	Title       pgtype.Text
	Description pgtype.Text
}

func (q *Queries) GetCoursesOverview(ctx context.Context) ([]GetCoursesOverviewRow, error) {
	rows, err := q.db.Query(ctx, getCoursesOverview)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCoursesOverviewRow
	for rows.Next() {
		var i GetCoursesOverviewRow
		if err := rows.Scan(&i.ID, &i.Title, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertCourseMaterial = `-- name: InsertCourseMaterial :exec
INSERT INTO course_materials (id, name, storage_key, position, course_id)
VALUES ($1, $2, $3, $4, $5)
`

type InsertCourseMaterialParams struct {
	ID         pgtype.UUID
	Name       string
	StorageKey pgtype.UUID
	Position   pgtype.Int4
	CourseID   pgtype.UUID
}

func (q *Queries) InsertCourseMaterial(ctx context.Context, arg InsertCourseMaterialParams) error {
	_, err := q.db.Exec(ctx, insertCourseMaterial,
		arg.ID,
		arg.Name,
		arg.StorageKey,
		arg.Position,
		arg.CourseID,
	)
	return err
}

const insertQuizAnswer = `-- name: InsertQuizAnswer :exec
INSERT INTO quizanswers (answer, correct_answer, position, quiz_question_id)
VALUES ($1, $2, $3, $4)
`

type InsertQuizAnswerParams struct {
	Answer         pgtype.Text
	CorrectAnswer  pgtype.Bool
	Position       pgtype.Int4
	QuizQuestionID pgtype.UUID
}

func (q *Queries) InsertQuizAnswer(ctx context.Context, arg InsertQuizAnswerParams) error {
	_, err := q.db.Exec(ctx, insertQuizAnswer,
		arg.Answer,
		arg.CorrectAnswer,
		arg.Position,
		arg.QuizQuestionID,
	)
	return err
}

const insertQuizQuestion = `-- name: InsertQuizQuestion :one
INSERT INTO quizquestions (question, position, is_multi_answer, quiz_section_id)
VALUES ($1, $2, $3, $4) RETURNING id
`

type InsertQuizQuestionParams struct {
	Question      pgtype.Text
	Position      pgtype.Int4
	IsMultiAnswer bool
	QuizSectionID pgtype.UUID
}

func (q *Queries) InsertQuizQuestion(ctx context.Context, arg InsertQuizQuestionParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, insertQuizQuestion,
		arg.Question,
		arg.Position,
		arg.IsMultiAnswer,
		arg.QuizSectionID,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const insertQuizSection = `-- name: InsertQuizSection :one
INSERT INTO quizsections (position, course_id) VALUES ($1, $2) RETURNING id
`

type InsertQuizSectionParams struct {
	Position pgtype.Int4
	CourseID pgtype.UUID
}

func (q *Queries) InsertQuizSection(ctx context.Context, arg InsertQuizSectionParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, insertQuizSection, arg.Position, arg.CourseID)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const insertVideoSection = `-- name: InsertVideoSection :exec
INSERT INTO videosections (title, storage_key, position, course_id)
VALUES ($1, $2, $3, $4)
`

type InsertVideoSectionParams struct {
	Title      pgtype.Text
	StorageKey pgtype.UUID
	Position   pgtype.Int4
	CourseID   pgtype.UUID
}

func (q *Queries) InsertVideoSection(ctx context.Context, arg InsertVideoSectionParams) error {
	_, err := q.db.Exec(ctx, insertVideoSection,
		arg.Title,
		arg.StorageKey,
		arg.Position,
		arg.CourseID,
	)
	return err
}
